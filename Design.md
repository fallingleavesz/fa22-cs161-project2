UCB CS161 Project 2 Design



#### Customized Data Structure

1.  `User` 

   ```
   type User struct {
   	Username string
   	// uuid           uuid.UUID
   	HashedPassword []byte
   	SourceKey      []byte
   	PKEEncKey      userlib.PKEEncKey
   	PKEDecKey      userlib.PKEDecKey
   	DSSignKey      userlib.DSSignKey
   	DSVerifyKey    userlib.DSVerifyKey
   }
   ```

   

2.   `UserFileMapEntry` & `UserFileMap`

   - `UserFileMapEntry` stores necessary info to find `FileMeta`, decrypt it, and check integrity.
   - `UserFileMap`: is a map, each entry is `{"filename (string)": UserFileMapEntry}`

   ```
   type UserFileMapEntry struct {
   	Status       string // Own / Share
   	FileMetaUUID uuid.UUID
   	SymEncKey    []byte
   	HMACKey      []byte
   }
   ```

   - `Status` indicates whether the user owns that file or not, which is useful for sharing and revocation

   ```
   // pseudocode
   UserFileMap: map,  {"filename (string)": UserFileMapEntry}
   ```

   ```
   var userFileMapEntry UserFileMapEntry
   userFileMap := make(map[string]UserFileMapEntry)
   ```

   

3.   `FileMeta` - store necessary data to find file, decrypt it, and check integrity.

   ```
   type FileMeta struct {
   	Owner        string
   	Status       string // FileMeta / Share
   	Filename     string
   	ShareList    uuid.UUID // point to ShareRecrods
   	FileUuidList []uuid.UUID
   	SymEncKey    []byte
   	HMACKey      []byte
   }
   ```

   

4. `ShareRecords` - a map to track sharing records for a specific file, each entry documents the essential information required to read the `fileMeta` of the shared file of the user who received the share

   ```
   // pseudocode
   shareMap {username : [uuid, shareFileMetaSymKey,shareFileMetaHMACKey]}
   ```

   ```
   var shareRecords [][]byte
   shareMap := make(map[string][][]byte)
   ```

   

#### Function Design

1. **InitUser** - Creates a new User struct and returns a pointer to it. The User struct includes all data required by the client to operate on behalf of the user.

   ```
   func InitUser(username string, password string) (userdataptr *User, err error)
   ```

   1. calculate hashed password, generate uuid for `User` struct, and `sourceKey`. Add them to the `User` Struct
      - uuid is generated by `uuid.FromBytes(HashedUsername[:16])`, which is deterministic given username
   2. generate two RSA key pairs, one for public encryption, the other for digital signature. Add pulick keys to the Keystore and private keys to `User`
   3. generate a symmetric key used for encrypting  `User` Struct in datastore from the hashedPassword and hashedUsername, which is also deterministic given password and username
   4. Store `User` to datastore (symEnc + hash)

   

2. **GetUser** - Obtains the User struct of a user who has already been initialized and returns a pointer to it

   ```
   func GetUser(username string, password string) (userdataptr *User, err error)
   ```

   1. calculate hashed username & password, deterministic uuid (from hashed username), deterministic  symKey (from both hashed username & password)
   2. use uuid to read User Struct from datastore, decrypt it, and check integrity -> get `User` Struct

   

3.  **StoreFile **- Given a `filename` in the personal namespace of the caller, this function persistently stores the given `content` for future retrieval using the same `filename`

   ```
   func (userdata *User) StoreFile(filename string, content []byte) (err error)
   ```

   1. calculate deterministic `UserFileMap` encryption and HMAC key (from `User.SourceKey` and string `UserFileMap-SymEnc` or `UserFileMap-HMAC`) 

   2. Create`userFileMap` & `UserFileMapEntry` & `FileMeta ` variables

   3. calculate deterministic `UserFileMap` UUID, and read `UserFileMap` from datastores

      - if `UserFileMap` exists, symDec it and check integrity -> get `UserFileMap` Struct

      - if `UserFileMap` does not exist, do nothing (we have initialize a blank `UserFileMap` Struct in step 2)

   4. Judge whether the file to be stored exist or not by checking whether the `userFileMapEntry` for that file exists or not

      - not exist -- first time to store the file, must be owner
        1. Init `userFileMapEntry` for that file (generate `FileMetaUUID`, FileMeta's `SymEncKey`, and FileMeta's `HMACKey` & add it into `UserFileMaP`)
        2. Init `FileMeta` for that file (generate file `SymKey`, `HMACKey`, and others)

      - exist -- have stored the file before
        1. read fileMeta from datastore (decrypt, check integrity from the key in userFileMapEntry for that fileMeta)
        2. based on the fileMeta.ShareList, read all the contents of the file from datastore
        3. delete original files stored in datastore

   5. store `UserFileMap`, `FileMeta`, `FileContent` to datastore (symEnc + HMAC)

   

4.  **AppendToFile**

   ```
   func (userdata *User) AppendToFile(filename string, content []byte) error
   ```

   

5.  **LoadFile**

   ```
   func (userdata *User) LoadFile(filename string) (content []byte, err error)
   ```

   

6.  

   ```
   func (userdata *User) CreateInvitation(filename string, recipientUsername string) (invitationPtr uuid.UUID, err error)
   ```

   

7.  

   ```
   func (userdata *User) AcceptInvitation(senderUsername string, invitationPtr uuid.UUID, filename string) error
   ```

8. ```
   func (userdata *User) RevokeAccess(filename string, recipientUsername string) error
   ```

   



Sharing and Revocation

